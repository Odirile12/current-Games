  // Camera follow logic with dead zone and smooth movement

class Player {
  constructor(stage) {
    this.stage = stage;
    this.keysPressed = {};
    this.bullets = [];
    this.ammo = 100;
    this.currentAmmo = 30;
    this.reloadDuration = 2000; // Reload time in milliseconds
    this.reloading = false;
    this.player = this.declare("player", 300, 600);
    this.playerHealth = 100;
    this.isJumping = false; // Add jumping state to prevent multiple jumps
    
    // Mario-style jump physics
    this.velocityY = 0;
    this.velocityX = 0;
    this.gravity = 0.8; // How fast player falls
    this.jumpPower = -16; // Initial jump velocity (negative = up)
    this.groundY = 600; // Ground level
    this.maxSpeed = 8; // Max horizontal speed
    this.acceleration = 1.2; // How fast player accelerates
    this.friction = 0.85; // How much speed is lost when not moving
    
    // Camera settings
    this.cameraDeadZone = 200; // Distance from center before camera moves
    this.cameraSmoothness = 0.1; // How smooth camera follows (0.1 = smooth, 1.0 = instant)
    this.levelWidth = 3200; // Set your level width here
    this.levelHeight = 800; // Set your level height here
    
    this.initEvents();
    
    // Start physics update loop
    this.startPhysicsLoop();
  }
    updateCamera() {
    const canvasWidth = this.stage.canvas.width;
    const canvasHeight = this.stage.canvas.height;
    
    // Calculate where camera should be to center player
    const targetCameraX = -(this.player.x - canvasWidth / 2);
    const targetCameraY = -(this.player.y - canvasHeight / 2);
    
    // Apply dead zone - only move camera if player is far from center
    const centerX = canvasWidth / 2;
    const centerY = canvasHeight / 2;
    const playerScreenX = this.player.x + this.stage.x;
    const playerScreenY = this.player.y + this.stage.y;
    
    let newCameraX = this.stage.x;
    let newCameraY = this.stage.y;
    
    // Check if player is outside dead zone horizontally
    if (Math.abs(playerScreenX - centerX) > this.cameraDeadZone) {
      newCameraX += (targetCameraX - this.stage.x) * this.cameraSmoothness;
    }
    
    // Check if player is outside dead zone vertically (for jumping)
    if (Math.abs(playerScreenY - centerY) > this.cameraDeadZone * 0.5) {
      newCameraY += (targetCameraY - this.stage.y) * this.cameraSmoothness;
    }
    
    // Clamp camera to level boundaries
    const maxCameraX = 0;
    const minCameraX = -(this.levelWidth - canvasWidth);
    const maxCameraY = 0;
    const minCameraY = -(this.levelHeight - canvasHeight);
    
    this.stage.x = Math.max(minCameraX, Math.min(maxCameraX, newCameraX));
    this.stage.y = Math.max(minCameraY, Math.min(maxCameraY, newCameraY));
  }// Game Class

  declare(name, x, y) {
    const button = new lib[name]();
    this.stage.addChild(button);
    button.x = x;
    button.y = y;
    return button;
  }

  takeDamage(amount) {
    this.playerHealth -= amount;
    console.log( "Player took " + amount + " damage. Health = " + this.playerHealth);

    if (this.playerHealth <= 0) {
      this.playerHealth = 0;
      console.log("Player has died!");
      this.stage.removeChild(this.player)
      // Fire custom event
      //this.player.dispatchEvent("dead");
    }
  }

  heal(amount) {
    this.playerHealth += amount;
    if (this.playerHealth > 100) this.playerHealth = 100; // cap health
    console.log( "Player healed. Health = " + this.playerHealth);
  }

  initEvents() {
    window.addEventListener("keydown", (event) => this.handleKeyDown(event));
    window.addEventListener("keyup", (event) => this.handleKeyUp(event));
  }

  handleKeyDown(event) {
    this.keysPressed[event.code] = true;

    switch (event.keyCode) {
      case 68: // D key - move right
        // Mario-style movement is handled in physics loop
        break;
      case 65: // A key - move left
        // Mario-style movement is handled in physics loop
        break;
      case 32: // Space key - Mario jump
        this.jump();
        break;
      case 69: // E key (fire)
        this.fire();
        break;
      case 82: // R key (reload)
        this.reloadAmmo();
        break;
    }
  }

  handleKeyUp(event) {
    delete this.keysPressed[event.code];
  }

  // Mario-style physics update loop
  startPhysicsLoop() {
    createjs.Ticker.addEventListener("tick", () => this.updatePhysics());
  }

  updatePhysics() {
    // Handle horizontal movement (Mario-style)
    if (this.keysPressed["KeyD"]) {
      this.velocityX = Math.min(this.velocityX + this.acceleration, this.maxSpeed);
      if (this.player.scaleX < 0) this.player.scaleX *= -1; // Face right
    } else if (this.keysPressed["KeyA"]) {
      this.velocityX = Math.max(this.velocityX - this.acceleration, -this.maxSpeed);
      if (this.player.scaleX > 0) this.player.scaleX *= -1; // Face left
    } else {
      // Apply friction when no keys pressed
      this.velocityX *= this.friction;
      if (Math.abs(this.velocityX) < 0.1) this.velocityX = 0; // Stop tiny movements
    }

    // Apply horizontal movement
    this.player.x += this.velocityX;

    // Handle vertical movement (gravity and jumping)
    this.velocityY += this.gravity;
    this.player.y += this.velocityY;

    // Ground collision
    if (this.player.y >= this.groundY) {
      this.player.y = this.groundY;
      this.velocityY = 0;
      this.isJumping = false;
    } else {
      this.isJumping = true;
    }

    // Update camera
    this.updateCamera();
  }

  // Mario-style jump - can only jump when on ground
  jump() {
    if (!this.isJumping && this.player.y >= this.groundY) {
      this.velocityY = this.jumpPower;
      this.isJumping = true;
      console.log("Mario Jump!");
    }
  }

  fire() {
    if (this.currentAmmo > 0 && !this.reloading) {
      const direction = this.player.scaleX < 0 ? "right" : "left";
      const bullet = {
        instance: this.declare("fire", this.player.x, this.player.y - 15),
        direction: direction,
      };

      this.currentAmmo--;
      console.log("Fired! Ammo: " + this.currentAmmo + "/30, Reserve: " + this.ammo);

      const intervalId = setInterval(() => this.moveBullet(bullet, intervalId), 1000 / 128);
      this.bullets.push({ bullet, intervalId });
    } else if (this.reloading) {
      console.log("Can't shoot while reloading!");
    } else {
      console.log("Out of ammo! Press R to reload.");
      // Optional: Auto-reload when trying to fire with empty magazine
      // this.reloadAmmo();
    }
  }

  moveBullet(bullet, intervalId) {
    if (bullet.direction === "left") {
      bullet.instance.x += 20;
    } else {
      bullet.instance.x -= 20;
    }

    // Check if bullet hits zombie
    if (zombis && zombis.isAlive && isColliding(bullet.instance, zombis.zombi)) {
      console.log("Bullet hit zombie!");
      zombis.takeDamage(25); // Bullet does 25 damage (4 shots to kill)
      // Remove the bullet
      clearInterval(intervalId);
      this.bullets = this.bullets.filter((b) => b.intervalId !== intervalId);
      this.stage.removeChild(bullet.instance);
      return;
    }

    if (bullet.instance.x <= 1 || bullet.instance.x >= 1589) {
      clearInterval(intervalId);
      this.bullets = this.bullets.filter((b) => b.intervalId !== intervalId);
      this.stage.removeChild(bullet.instance);
    }
  }

  reloadAmmo() {
    // Can't reload if already reloading, no reserve ammo, or magazine is full
    if (this.reloading || this.ammo <= 0 || this.currentAmmo >= 30) {
      if (this.ammo <= 0) {
        console.log("No reserve ammo left!");
      } else if (this.currentAmmo >= 30) {
        console.log("Magazine is already full!");
      }
      return;
    }

    this.reloading = true;
    console.log("Reloading... (" + this.reloadDuration/1000 + " seconds)");
    
    // Use setTimeout instead of createjs.Ticker for simpler, more reliable timing
    setTimeout(() => {
      if (!this.reloading) return; // Check if reload was cancelled somehow
      
      // Calculate how much ammo to transfer from reserve to current
      const ammoNeeded = 30 - this.currentAmmo;  // How much space in magazine
      const ammoToAdd = Math.min(ammoNeeded, this.ammo);  // Don't exceed reserve ammo
      
      // Transfer ammo
      this.currentAmmo += ammoToAdd;
      this.ammo -= ammoToAdd;
      
      // Finish reloading
      this.reloading = false;
      console.log("Reload complete! Magazine: " + this.currentAmmo + "/30, Reserve: " + this.ammo);
      
    }, this.reloadDuration);
  }
}

// Zombi Class
class Zombi {
  constructor(ThePlayer) {
    this.Player = ThePlayer;
    this.zombi = this.declare("zombi", 0, 600);
    this.zombieHealth = 100; // Add zombie health
    this.isAlive = true; // Add alive state
    createjs.Ticker.addEventListener("tick", this.follow.bind(this));
    console.log("Zombi position is: x=" + this.zombi.x + ", nominalBounds=" + this.zombi.scaleX);
    console.log("Player position is: x=" + this.Player.player.x + ", nominalBounds=" + this.Player.player.scaleX);
  }

  declare(name, x, y) {
    const button = new lib[name]();
    stage.addChild(button);
    button.x = x;
    button.y = y;
    return button;
  }

  // Add method for zombie to take damage
  takeDamage(amount) {
    if (!this.isAlive) return;
    
    this.zombieHealth -= amount;
    console.log("Zombie took " + amount + " damage. Health = " + this.zombieHealth);

    if (this.zombieHealth <= 0) {
      this.zombieHealth = 0;
      this.isAlive = false;
      console.log("Zombie has died!");
      stage.removeChild(this.zombi);
      // Remove the tick listener when zombie dies
      createjs.Ticker.removeEventListener("tick", this.follow);
    }
  }

  between(value, min, max) {
    return value >= min && value <= max;
  }
  
  follow(event) {
    if (!this.isAlive) return; // Don't move if dead
    
    if (this.between(zombis.zombi.x, player1.player.x - 20, player1.player.x + 20) == false) {
      if (player1.player.x > zombis.zombi.x) {
        // Player is to the right, zombie moves right and faces right
        zombis.zombi.x += 3;
        if (zombis.zombi.scaleX < 0) zombis.zombi.scaleX = Math.abs(zombis.zombi.scaleX); // Face right
      } else {
        // Player is to the left, zombie moves left and faces left
        zombis.zombi.x -= 3;
        if (zombis.zombi.scaleX > 0) zombis.zombi.scaleX = -Math.abs(zombis.zombi.scaleX); // Face left
      }
    }

    if (isColliding(this.zombi, this.Player.player) && this.Player.playerHealth != 0) {
      console.log("Zombi hit the player!");
      this.Player.takeDamage(1);
      console.log(this.Player.playerHealth);
    }
  }
}

function isColliding(obj1, obj2) {
  // Prefer getBounds(), fallback to nominalBounds
  let bounds1 = obj1.getBounds ? obj1.getBounds() : null;
  let bounds2 = obj2.getBounds ? obj2.getBounds() : null;

  if (!bounds1 && obj1.nominalBounds) bounds1 = obj1.nominalBounds;
  if (!bounds2 && obj2.nominalBounds) bounds2 = obj2.nominalBounds;

  if (!bounds1 || !bounds2) {
    console.warn("Could not determine bounds for collision check.");
    return false;
  }

  // Account for each object's transform
  let x1 = obj1.x - bounds1.width / 2;
  let y1 = obj1.y - bounds1.height / 2;
  let x2 = obj2.x - bounds2.width / 2;
  let y2 = obj2.y - bounds2.height / 2;

  return !(
    x1 + bounds1.width < x2 ||
    x1 > x2 + bounds2.width ||
    y1 + bounds1.height < y2 ||
    y1 > y2 + bounds2.height
  );
}

const stageGame = new createjs.Stage("canvas");
stage.stop();
const player1 = new Player(stage);
console.log(player1)

const zombis = new Zombi(player1);